# -*- coding: utf-8 -*-
"""
    main.py

    :project : studylen
    :date    : 2019-03-15 15:02:36
"""

import sys
import os
try:
  import pchain
except :  
  pchain_path = os.path.join(os.path.dirname(os.path.abspath(__file__)),'../')
  sys.path.insert(0,pchain_path)
  import pchain
from pchain import pydata
from pchain import pyproc
from pchain.pydata import PCPyDataClass
from pchain.pyproc import PCPyProcClass

Service = pchain.cleinit()
import libstarpy

realm = Service.PCRealmBase._New()

pydata.DefineType('StringClass',str)
pydata.DefineType('NumberClass',int)

#define class

@pyproc.DefineProc('MyProc1',StringClass,NumberClass)
def Execute(self,strobj) :
  Context = self.Context
  val = len(strobj.value())
  return (0,1,NumberClass(val))

@pyproc.DefineProc('MyProc2',StringClass,NumberClass)
def Execute(self,strobj) :
  Context = self.Context
  val = 0
  try:
    val = int(strobj.value())
    return (0,1,NumberClass(val))
  except :
    return (0,-1,None)

def _HasEqualObject(dataset,procbuf_para) :
  for t in dataset :
    for l in procbuf_para :
      if t.Equals(l[0]) :
        return True
  return False

@pyproc.DefineProc('EqualRuleProc',Service.PCRealmFrameData,())
def Execute(self,FrameData) :
    Context = self.Context
    RootProc = pyproc.UnWrap(Context['SelfObj'].GetRootProc())
    
    sameset = Context['SelfObj'].EqualDataSet(FrameData.GetDataBuf())
    
    #--only handle dynamic generated data object
    sameset_clean = [t for t in sameset if len(t) >= 2]
    if len(sameset_clean) == 0 :
      return None      
    
    #--for simple, here only process sameset_clean[0]
    dataset = Context['SelfObj'].SplitDataSet(FrameData.GetDataBuf(),sameset_clean[0], True)   
    
    #--Remove redundant data object, If the data object is the output of a process object, the data object is redundant, and the data object is removed
    procset = [t for t in dataset[0] if Service.PCProcBase._IsInst(t)]
        
    #--find source data from output data and procs
    sourceset = []
    for t in dataset[0] :
      if Service.PCDataBase._IsInst(t) :
        for l in procset :
          if t.IsFromProc(l) == True :  # t is output data via proc t
            for m in dataset[0] :
              if Service.PCDataBase._IsInst(m) :
                if t.IsSource(m) :        # add source data of t
                  sourceset.append(m)
    
    #If a process rejects a data object as input, it is removed from the process group
    newprocset = []    
    for l in procset :
      IsReject = False
      for t in sourceset :
        if t.IsReject(l) :
          IsReject = True
      if IsReject == False :
        newprocset.append(l)
    procset = newprocset

    #--Remove the data generated by the process in the relateset from the context
    contextset = []
    for t in dataset[1] :
      if Service.PCDataBase._IsInst(t) :
        isoutputdata = False      
        for l in procset :          
          if t.IsFromProc(l) == True :
            isoutputdata = True
            break
        if isoutputdata == False :
          contextset.append(t)
      else :
        contextset.append(t)     
    
    v = ''
    for t in procset :
      if len(v) == 0 :
        v = v + str(t)
      else :
        v = v + ',' + str(t)
    
    v = ''
    for t in sourceset :
      if len(v) == 0 :
        v = v + str(t)
      else :
        v = v + ',' + str(t)
    
    v = ''
    for t in contextset :
      if len(v) == 0 :
        v = v + str(t)
      else :
        v = v + ',' + str(t)
    
    #--If no data has been stored before
    if RootProc.LocalBuf == None :
      s1 = [[t,1.0] for t in procset]

      #for source, here use it type    
      s2 = []      
      for t in sourceset :
        newflag = True
        p = t.GetType()
        for l in s2 :
          if p.Equals(l[0]) :
            newflag = False
            l[1] = l[1] + 1.0  
        if newflag == True :
          s2.append([p,1.0])  
                        
      s3 = []
      for t in contextset :
        s3.append([t,1.0])
      RootProc.LocalBuf = [s1,s2,s3]
    else :
      #--If there is the same object, it is considered that there is a correlation between the two runs.
      if _HasEqualObject(procset,RootProc.LocalBuf[0]) and _HasEqualObject(contextset,RootProc.LocalBuf[2]) :
        # increase count for equal object
        for t in procset :
          newflag = True
          for l in RootProc.LocalBuf[0] :
            if t.Equals(l[0]) :
              newflag = False
              l[1] = l[1] + 1.0
          if newflag == True :
            RootProc.LocalBuf[0].append([t,1.0])
            
        #for source, here use it type    
        for t in sourceset :
          newflag = True
          p = t.GetType()   # use it's class object
          for l in RootProc.LocalBuf[1] :
            if p.Equals(l[0]) :
              newflag = False
              l[1] = l[1] + 1.0  
          if newflag == True :
            RootProc.LocalBuf[1].append([p,1.0])  
                           
        for t in contextset :
          newflag = True        
          for l in RootProc.LocalBuf[2] :
            if t.Equals(l[0]) :
              newflag = False
              l[1] = l[1] + 1.0                
          if newflag == True :
            RootProc.LocalBuf[1].append([t,1.0])  
                    
        # Calculate the average number of times and remove objects that are less than the average number of times
        means = 0
        for l in RootProc.LocalBuf[0] :
          means = means + l[1]
        means = means / len(RootProc.LocalBuf[0])
        
        newprocset = []
        for l in RootProc.LocalBuf[0] :
          if l[1] < means :
            pass
          else :
            newprocset.append(l)
        RootProc.LocalBuf[0] = newprocset
        
        #--source
        means = 0
        for l in RootProc.LocalBuf[1] :
          means = means + l[1]
        means = means / len(RootProc.LocalBuf[1])  
        
        newsourceset = []
        for l in RootProc.LocalBuf[1] :
          if l[1] < means :
            pass
          else :
            newsourceset.append(l)
        RootProc.LocalBuf[1] = newsourceset
        
        means = 0
        for l in RootProc.LocalBuf[2] :
          means = means + l[1]
        means = means / len(RootProc.LocalBuf[2])  
                
        newcontextset = []
        for l in RootProc.LocalBuf[2] :
          if l[1] < means :
            pass
          else :
            newcontextset.append(l)
        RootProc.LocalBuf[2] = newcontextset        
        
        #--output relations
        value0 = ''
        for l in RootProc.LocalBuf[0] :
          if len(value0) == 0 :
            value0 = value0 + str(l[0])
          else :
            value0 = value0 + ',' + str(l[0])
            
        value1 = ''
        for l in RootProc.LocalBuf[1] :
          if len(value1) == 0 :
            value1 = value1 + str(l[0])
          else :
            value1 = value1 + ',' + str(l[0])            
           
        value2 = ''
        for l in RootProc.LocalBuf[2] :
          if len(value2) == 0 :
            value2 = value2 + str(l[0])
          else :
            value2 = value2 + ',' + str(l[0])
            
        print('find relation :  [context:'+value2+']source:'+value1+' -> process:'+value0)

      else :
        RootProc.LocalBuf = None  #--clear record      
    return None
    

cell = Service.PCCellBase._New()
cell.AddProc(MyProc1,MyProc2)
realm.AddCellLibrary(cell)
  
#define how to handle  
@realm._RegScriptProc_P('OnBeforeExecute')
def realm_OnBeforeExecute(CleObj):
  envdata = CleObj.GetEnvDataQueue()
  for data in envdata :  
    CleObj.EnvDataToCell(data)
  return  

@realm._RegScriptProc_P('OnCellFinish')
def realm_OnCellFinish(CleObj,cell,IsSuccess):
  CleObj.ProcessCellEnvData(cell,IsSuccess);
  CleObj.MoveToCellLibrary(cell)
  
@realm._RegScriptProc_P('OnFrameData')
def realm_OnFrameData(CleObj,FrameData):
  LocalBuf = CleObj.GetLocalBuf()
  RuleRealm = LocalBuf['RuleRealm']
  if RuleRealm == None :
    RuleRealm = Service.PCRealmBase._New()
    LocalBuf['RuleRealm'] = RuleRealm
  RuleRealm.SyncFrom(CleObj,False)
  #--add data
  #--get the cell, which can accept the FrameData
  Cells = RuleRealm.GetCellForInput(FrameData)
  if Cells._Number == 0 :
    newcell = Service.PCCellBase._New()
    newcell.AddProc(Service.EqualRuleProc)  
    RuleRealm.AddCell(newcell)
    Cells = RuleRealm.GetCellForInput(FrameData)
  Cells[0].AddEnvData(RuleRealm,FrameData)
  RuleRealm.Execute()  
  
  
#--we add it to neo4j
print('the app will insert node to neo4j, run carefully')
from py2neo import Graph,Node,Relationship
from py2neo import NodeMatcher
from py2neo import RelationshipMatcher

graph = Graph('http://localhost:7474',username='neo4j',password='970511')
matcher = NodeMatcher(graph)
rel_matcher = RelationshipMatcher(graph)
#graph.delete_all()

def insert_to_neo4j(t) :
  #--find node by name, and label
  c_type = t.GetTagLabel()
  c_tag = t.GetTag()
  node = matcher.match(c_type, name=c_tag).first()
  if node == None :
    print('insert node  ',c_type,'   :  ',c_tag)
    node = Node(c_type,name=c_tag)
    graph.create(node)
  #--t's class type exist?
  item_type = t.GetType()
  t_tag_label = item_type.GetTagLabel()
  t_tag = item_type.GetTag()
  c_node = matcher.match(t_tag_label, name=t_tag).first()
  if c_node == None :
    print('insert type  ',t_tag_label,'   :  ',t_tag)
    c_node = Node(t_tag_label,name=t_tag)
    graph.create(c_node)
  #--
  if c_node == node :
    pass
  else :
    is_inst = rel_matcher.match((c_node,node), r_type="istype").first()
    if is_inst == None :
      is_inst = Relationship(c_node,'istype',node)
      graph.create(is_inst)  
      
  #--create relations using source
  srcs = realm.GetSourceObject(t)      
  for src in srcs :
    src_type = src.GetTagLabel()
    src_tag = src.GetTag()
    src_node = matcher.match(src_type, name=src_tag).first()    
    if src_node == None :
      insert_to_neo4j(src)
      src_type = src.GetTagLabel()
      src_tag = src.GetTag()
      src_node = matcher.match(src_type, name=src_tag).first()      
          
    r_type_name = 'sourcedata'
    if realm.IsProc(src) == True :
      r_type_name = 'output'
      
    is_source = rel_matcher.match((src_node,node), r_type=r_type_name).first()
    if is_source == None :
      is_source = Relationship(src_node,r_type_name,node)
      graph.create(is_source)      

realm.AddEnvData(StringClass('qqqwwweee'),StringClass('length'),StringClass('9'))
realm.Execute()

activeset = realm.GetActiveObject(None,1.0,0)
for t in activeset :
  insert_to_neo4j(t)   
  
realm.Reset(True)  

realm.AddEnvData(StringClass('tttttttt'),StringClass('length'),StringClass('8'))
realm.Execute()

activeset = realm.GetActiveObject(None,1.0,0)
for t in activeset :
  insert_to_neo4j(t)   
  
realm.Reset(True)  
  
#realm.AddEnvData(StringClass('ttttttttee'),StringClass('length'),StringClass('10'))
#realm.Execute()   
  
# enter loop
# pchain.cleloop()
# finish
pchain.cleterm() 
