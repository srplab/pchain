<h1 align="center">PCCellBase</h1>

The base classes for process management are PCProcBase, PCCellBase, PCProcChainBase, and PCProcRemoteBase. Usually use PCProcBase. 

**PCCellBase** and **PCProcRemoteBase** inherit the methods and properties of PCProcBase. PCProcRemoteBase is a remotely executed process class that is not fully supported in the current release. 

**PCCellBase** is an independent and schedulable unit. PCCell can contain multiple process chains. It can assign data objects to the process chain. When scheduling, create an execution object Runner according to the process chain in Cell.

The Cell is a scheduling execution unit consisting of a process chain, a Runner, and environment data.
The Cell contains multiple process chains, which are the basis for cell execution. When the Cell is scheduled to execute, the current environment data is allocated to the process chain, and if it can be allocated, the Runner corresponding to the process chain is generated.

For Runner, execution begins with the first process of the process chain. If the first process is assigned data and the data for at least one of the entries is complete, then the process execution is scheduled.

The output data of the last process in the process chain is placed in the environment data for distribution.

The environment data includes data objects from the outside, and also contains data objects generated by the process chain in this Cell.

*[A Cell can belong to a process chain or belong to Realm](#)*

Create cell type with input and output
------

Sometimes, the created Cell needs to set the input and output data types. At this point you can use the "Create" method. Unlike the PCProc, you cannot define the "Execute" function.

```python
Create(StarSpaceObject,CellTypeName,InputQueue,OutputQueue)
```

for example,

```python
MyCell = Service.PCCellBase.Create(None,"MyCell",(NumberClass),(NumberStepClass))
```

Cell can handle the scheduling process by defining the Execute function. For example

```python
mycell = Service.PCCellBase.Create(None,"mycell",None,NumberClass)
@mycell._RegScriptProc_P("Execute")
def Execute(cleobj,realm,cell,runner) :
  inputdata = cleobj.GetEnvData()
  ...
  cleobj.ClearEnvData()
  cleobj.AddOutputData(result)
  return 0
```

**In this case, there are a few points to note**

* The output data is added by the AddOutputData function. If the cell does not define the type of the output data, the data is placed in the EnvDataQueue of the cell.

* The returned result can be -1,0,1,2,3,4,.., If the cell belongs to realm, returning 2 or 3 indicates an execution error and ends, Return 1 means hang, the cell will not be scheduled again until the pending state is canceled.

Create instance of PCCell 
---

```python
cell = Service.PCCellBase._New()
or
cell = Service.PCCellBase()
```

Properties supported by PCCell
------

*[IsReady : bool](#)*
> * Whether the Cell is ready or not can be scheduled. For the Cell in the process chain, this flag is managed by pchain.
> * For the Cell in Realm, when calling Realm's function "EnvDataToCell", assign the environment data in a Realm to the Cell, or call "AddCell" to add the Cell to Realm, or call 'MoveToCellQueue", and the Cell from Realm. Move the CellLibrary queue to the Cell queue, or call Realm's "Reset" function.
IsReady is automatically set to true.
> * When calling Realm's function Execute, ExecuteForResult, and ExecuteUntil, the IsReady of the Cell in Realm is first set to true.
> * Other situations need set to true manually.


*[SingleRunnerFlag : bool](#)*

Equal to true(default), only one Runner can be generated for a process chain; otherwise, multiple Runners can be generated.


Functions supported by process management objects
------

#### a. basic function

*[GetTag](#)*

Return the string corresponding to the cell.

Tag is a string of 40 characters

**[cells with same type and of the same tag should be considered the same object](#)**

`VS_CHAR *GetTag()`

*[GetTagLabel](#)*

Get tag label, format is "cell_"+namespace+type name.

`VS_CHAR *GetTagLabel()`

*[AddEnvData](#)*

Add environment data to the Cell, you can add multiple at the same time
input parameter may be data objects or parapkg which holds multiple data object

`void AddEnvData(struct StructOfPCRealmBase *PCRealm,void *Data,...)`

**This function generate an instance of the input data object and add the instance to the Cell**

*[RemoveEnvData](#)*

Remove environment data from the Cell, you can remove multiple at the same time

`void RemoveEnvData(...)`

Input parameters can be parameter packages (Parapkg) or multiple data objects

*[ClearEnvData](#)*

Clear the environment datas which are instance of DataClass. If the DataClass is NULL, clear all  environment data.

`void ClearEnvData(struct StructOfPCDataBase *DataClass)`

*[AddProc](#)*

Add process or process chain to Cell, for process, pchain will automatically generates process chain for it.

`VS_BOOL AddProc(void *PCProcOrProcChain,...)`

*[ConnectProc](#)*

Connect multiple processes or process chains in order to form a new process chain and add it to the Cell.

`VS_BOOL ConnectProc(void *PCProcOrProcChain, ...)`

*[FindProc](#)*

Find process chains in a cell based on a process or process chain.

`struct StructOfPCProcChainBase *FindProc(void *PCProcOrProcChain)`

*[LastProc](#)*

Find process chains in a cell based on a process which is the last process of the chain.

`struct StructOfPCProcChainBase *LastProc(void *PCProc)`

*[CollectProcOutput](#)*

Get all output data types of the process chain in the Cell.

`VS_PARAPKGPTR CollectProcOutput()`

*[DataCanBeAsInput](#)*

Whether the data object can be used as the input data object. 

`VS_BOOL DataCanBeAsInput(struct StructOfPCDataBase *PCData)`

*[DataCanBeAsOutput](#)*

Whether the data object is output of the cell. 

`VS_BOOL DataCanBeAsOutput(struct StructOfPCDataBase *PCData)`

*[GetEnvData](#)*

Obtain the environment data queue of the PCDataBase instance. If PCDataBase is NULL, all the environment data is returned.

`VS_PARAPKGPTR GetEnvData(void *PCDataBase)`

*[GetNewEnvData](#)*

Obtain the environment data queue of the PCDataBase instance created when executing. If PCDataBase is NULL, all the environment data is returned.

`VS_PARAPKGPTR GetNewEnvData(void *PCDataBase)`

*[GetEnvDataUnHandled](#)*

Get unprocessed environment data in the Cell. 
The condition that the data is not processed is that the data has not been allocated, or, although it has been allocated, it has not been executed.

`VS_PARAPKGPTR GetEnvDataUnHandled(void *PCDataBase,VS_INT32 Type)`

PCDataBase : PCDataBase can be NULL
Type:
> * 0 : All unprocessed data, including externally imported data and data generated during the run
> * 1 : return externally imported data which are not handled
> * 2 : return internal generated data which are not handled

*[IsFromOutSide](#)*

The environment data is from outside of the cell

`VS_BOOL IsFromOutSide(void *PCDataBase)`

*[GetEqualData](#)*

Get equal data objects in the environment data queue.

`void *GetEqualData(void *PCDataBase)`

*[GetProcChainQueue](#)*

Get the process chain queue in the Cell, return a list of process chain objects

`VS_PARAPKGPTR GetProcChainQueue()`


*[GetMissingEnvData](#)*

Get the missing environment data class. If there is a corresponding data object instance externally, it may be assigned to this Cell. This function is judged for each Runner, according to the input queue of the process which current pointer points to , if it need to input from the external environment, and the input data is missing, then record it in ParaPkg.

`VS_PARAPKGPTR GetMissingEnvData()`


*[GetMissingEnvDataProc](#)*

Obtain process which needs environment data

`VS_PARAPKGPTR GetMissingEnvDataProc()`

*[IsProcExecuted](#)*

Whether the process has been executed, at least once

`VS_BOOL IsProcExecuted(struct StructOfPCProcBase *PCProc)`

*[GetCellMissingOutput](#)*

Valid when the Cell is scheduled, usually used in the OnCellToBeFinish callback function.
First, call GetCellMissingOutput to get all the types that have no output, then call IsCellOutputMustExist to see if each type is required. If all is not required, then there should be a mandatory output by default.

`VS_PARAPKGPTR GetCellMissingOutput()`

*[IsCellOutputMustExist](#)*

`VS_BOOL IsCellOutputMustExist(struct StructOfPCDataBase *OutputDataType)`


*[NumberOfEnvData](#)*

Gets the number of environment objects that can be assigned to a process object.

`VS_INT32 NumberOfEnvData(struct StructOfPCProcBase *PCProc,VS_INT32 InputIndex,VS_BOOL IncludeConnectedData)`

If InputIndex<0, all inputs are calculated, otherwise the specified input is calculated, and based on the input DataClass, it is determined:
Get the number of instances of DataClass that can be assigned to PCProc.
This function retrieves the instance of the EnvDataQueue that belongs to the DataClass in turn, and determines whether ExcludeProc already contains PCProc. If it is not included, it means that it can be assigned, and the number of statistics can be allocated.
If IncludeConnectedData is equal to false, the data already assigned to the process is not calculated.

*[IsFinishExcept](#)*

The data object has been processed by all processes other than PCProc

`VS_BOOL IsFinishExcept(struct StructOfPCDataBase *PCData, struct StructOfPCProcBase *PCProc)`

*[NumberOfRunner](#)*

Get the number of instances of this Process, which must be called in the Execute function

`VS_INT32 NumberOfRunner(struct StructOfPCProcBase *PCProc)`


*[Finish](#)*

End the execution of the Cell, which sets the Cell's IsReady to false

`void Finish()`

*[OnCellToBeFinish](#)*

Called before the end of the Cell's execution.

`VS_BOOL OnCellToBeFinish(struct StructOfPCRealmBase *Realm)`

This callback can add a new process chain, new data, and can set IsSuspend equal to true.

**[In the callback function, app can call GetEnvDataUnHandled to get the environment data that can not be processed, and, call GetMissingEnvDataProc/GetCellMissingOutput/IsCellOutputMustExist to get the process that cannot be executed due to missing input.](#)**


If IsSuspend is false, and the function returns false, then an OnCellFinish callback will be called, and the Cell schedule ends.

If the function returns true and IsSuspend is equal to false, the Cell continues to schedule. And does not call the OnCellFinish callback function

*[OnCellFinish](#)*

Callback function before the end of Cell execution.

`void OnCellFinish(struct StructOfPCRealmBase *Realm,VS_BOOL IsSuccess)`

IsSuccess 
> * true : No error occurred during cell execution
> * false : An error occurred during cell execution

*[CreateType](#)*

Create a Cell type. The parent class must be a PCCellBase, that is, it must be called via PCCellBase.

`void *CreateType(VS_CHAR *TypeName)`

<h1 align="center">PCProcRunnerBase</h1>

Properties supported by PCProcRunner
------

*[PCProcStart : VS_UUID(string)](#)*

The first process in Runner

*[RunningTickCount : VS_INT64](#)*

execution time. The unit is us

*[ErrorCount : VS_INT32](#)*

Execution error count


Functions supported by PCProcRunner
------


*[CurrentProcToParaPkg](#)*

Get the current pointer to be executed, return a list of process objects

`VS_PARAPKGPTR CurrentProcToParaPkg()`

*[ProcToParaPkg](#)*

Get a list of process instances in Runner

`VS_PARAPKGPTR ProcToParaPkg()`

*[GetProcChain](#)*

Get the process chain corresponding to the Runner

`void *GetProcChain()`

*[GetCell](#)*

Get the Cell to which the Runner belongs

`void *GetCell()`








